import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class GraphTest {

	/*
	 * This method tests the function DAG_tester() by ensuring it correctly detects valid DAGs
	 * and invalid DAGs.
	 */
	@Test
	void test() {
		
		// test 1: a graph where every node has at least one edge inward or outward
		// also not a DAG, so returns false
		Graph<String> graph = new Graph<String>(6);
		
		graph = graph.loadGraph("test1.txt");

        assertEquals(false, graph.DAG_tester());

        // test 2: a graph with one node with no inward or outward edges
        // this is a DAG, so returns true
        graph = graph.loadGraph("test2.txt"); // load graph from file
        
        System.out.println();
        assertEquals(true, graph.DAG_tester());
        
        // test 3: a graph with no edges
        // this is a DAG, so returns true
        graph = graph.loadGraph("test3.txt");
        
        System.out.println();
        assertEquals(true, graph.DAG_tester());
        
        // test 0: a graph with no nodes
        // this is a DAG, so returns true
        graph = graph.loadGraph("test0.txt");
        System.out.println();
        assertEquals(true, graph.DAG_tester());
        
        // test 4: a graph which is one big cycle
        // this is not a DAG, returns false
        graph = graph.loadGraph("test4.txt");
        System.out.println();
        assertEquals(false, graph.DAG_tester());

	}
	
	
	
	/*
	 * This function tests the loadGraph() method by comparing the matrix generated by loadGraph()
	 * to the expected matrix of the graph in the given file.
	 */
	@Test
	void loadGraph_test() {
		
		Graph<String> graph = new Graph<String>(0);
		
		// test 1: a graph where every line has 2 nodes
		graph = graph.loadGraph("test1.txt"); // load in from test1.txt
		
		// expected matrix for test1.txt
		boolean expectedMatrix[][] = { 
				{false, false, false, false, false, false}, 
				{true, false, true, false, false, false}, 
				{false, true, false, false, false, false}, 
				{false, true, false, false, false, false}, 
				{false, false, false, false, false, false}, 
				{false, false, false, false, true, false} 
				};
		
		assertEquals(true, matrixMatcher(graph.getMatrix(), expectedMatrix)); // ensure actual matrix matches expected matrix
		
		
		
		// test 2: a graph where a single line has only one node
		graph = graph.loadGraph("test2.txt"); // load in from test2.txt
		
		// expected matrix for test2.txt
		boolean expectedMatrix2[][] = { 
				{false, false, false, false, false, false, false}, 
				{true, false, true, false, false, false, false}, 
				{false, false, false, false, false, false, false}, 
				{false, true, false, false, false, false, false}, 
				{false, false, false, false, false, false, false}, 
				{false, false, false, false, true, false, false}, 
				{false, false, false, false, false, false, false} 
				};

		assertEquals(true, matrixMatcher(graph.getMatrix(), expectedMatrix2)); // ensure actual matrix matches expected matrix
		
		
		
		// test 3: a graph where every line has only one node
		graph = graph.loadGraph("test3.txt");
		
		// expected matrix for test3.txt
		boolean expectedMatrix3[][] = { 
				{false, false, false}, 
				{false, false, false}, 
				{false, false, false}, 
				};
		
		assertEquals(true, matrixMatcher(graph.getMatrix(), expectedMatrix3)); // ensure actual matrix matches expected matrix

		
		
		// test 4: a graph with no nodes
		graph = graph.loadGraph("test0.txt");
		
		// expceted matrix for test0.txt
		boolean expectedMatrix0[][] = new boolean[0][0];
		
		assertEquals(true, matrixMatcher(graph.getMatrix(), expectedMatrix0)); // ensure actual matrix matches expected matrix
		
	}
	
	
	
	/*
	 * This is a helper functon which ensures that 2 given matrixes are identical.
	 */
	boolean matrixMatcher(boolean[][] a, boolean[][] b) {
		
		if (a.length != b.length) { return false; } // diff lengths, not equal
		
		for (int y = 0; y < a.length; y++) {
			if (a[y].length != b[y].length) { return false; } // diff lengths, not equal
			for (int x = 0; x < a[y].length; x++) {
				//System.out.println(a[y][x] + " == " + b[y][x]);
				if (a[y][x] != b[y][x]) { return false; } // difference found
			}
		}
		return true;
	}

}
